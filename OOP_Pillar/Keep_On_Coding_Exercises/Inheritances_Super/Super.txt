Perfect â€” your inheritance setup is already solid ğŸ‘

Now, letâ€™s introduce the `super` keyword and understand what it does.

---

### ğŸ”¹ What is `super` in Java?

`super` is used to **refer to the parent (superclass) members** â€” either **fields**, **methods**, or **constructors**.

There are **3 main uses** of `super`:

1. **Call the parent class method** (if itâ€™s overridden in the subclass)
2. **Access the parent class variable** (if itâ€™s hidden by a subclass variable)
3. **Call the parent class constructor** (to initialize superclass attributes)

---

### ğŸ§› Modified Example with `super`

Hereâ€™s your updated code with `super` in use:

#### **Enemy.java**

```java
package OOP_Pillar.Keep_On_Coding_Exercises.Inheritances;

public class Enemy {

    int health = 100;

    public void talk() {
        System.out.println("I am an enemy! You better RUN!!!");
    } 

    public void showHealth() {
        System.out.println("Enemy Health: " + health);
    }
}
```

#### **Vampire.java**

```java
package OOP_Pillar.Keep_On_Coding_Exercises.Inheritances;

public class Vampire extends Enemy {

    int health = 150; // This hides the parent's 'health' variable

    @Override
    public void talk() {
        super.talk(); // ğŸ‘ˆ Calls the 'talk()' method from Enemy
        System.out.println("I Want To Suck Your Blood!");
    }

    public void showBothHealth() {
        System.out.println("Vampire Health: " + health);
        System.out.println("Enemy Health (using super): " + super.health); // ğŸ‘ˆ Access parent's variable
    }

    // ğŸ‘‡ Call parent constructor example (if Enemy had one)
    public Vampire() {
        super(); // Calls Enemy's constructor (optional if parent has default)
    }
}
```

#### **Main.java**

```java
package OOP_Pillar.Keep_On_Coding_Exercises.Inheritances;

class Main {

    public static void main(String[] args) {
        
        Vampire vampire = new Vampire();
        vampire.talk();
        vampire.showBothHealth();
    }
}
```

---

### ğŸ§  Explanation

#### 1. **`super.talk()`**

* Normally, when you override a method (like `talk()`), the subclass method *replaces* the parentâ€™s.
* But if you still want to use the parentâ€™s version, call it with `super.talk()`.

  **Output:**

  ```
  I am an enemy! You better RUN!!!
  I Want To Suck Your Blood!
  ```

#### 2. **`super.health`**

* The subclass `Vampire` also has its own `health` variable.
* If both parent and child have variables with the same name, you can use `super.variableName` to access the parentâ€™s.

  **Output:**

  ```
  Vampire Health: 150
  Enemy Health (using super): 100
  ```

#### 3. **`super()` in Constructor**

* If the parent class has a constructor that needs to run first (e.g., to initialize something), you can explicitly call it using `super()` inside the child constructor.
* Java automatically adds `super();` if you donâ€™t write it, **but only if the parent has a no-argument constructor**.

---

### ğŸ§© Summary Table

| Usage                | Example         | Meaning                                |
| -------------------- | --------------- | -------------------------------------- |
| `super.methodName()` | `super.talk();` | Calls the parentâ€™s version of a method |
| `super.variableName` | `super.health`  | Refers to the parentâ€™s variable        |
| `super()`            | `super();`      | Calls the parentâ€™s constructor         |

---




More Example:
Excellent question again ğŸ‘ â€” and this is a **common confusion** for beginners in Java OOP.

Letâ€™s break it down simply ğŸ‘‡

---

## ğŸ§© Short answer

You **canâ€™t** use `super.Animal` (or `super.animals`) because:

> ğŸ”¹ `super` is **not an object** â€” itâ€™s a **keyword** used to refer to the *parent classâ€™s members*, not the class itself.

So:

* âœ… `super()` â†’ calls **parentâ€™s constructor**
* âœ… `super.someMethod()` â†’ calls **a method from the parent class**
* âŒ `super.Animal` â†’ invalid syntax; `super` doesnâ€™t refer to the class name

---

## ğŸ§  Think of `super` like this:

`super` gives you **access to whatâ€™s inside the parent**,
not the **parent itself** as a type.

Example:

```java
class Animal {
    public void eat() {
        System.out.println("Animal is eating.");
    }
}

class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("Dog is eating.");
    }

    public void showEating() {
        super.eat(); // âœ… calls the parent (Animal)â€™s eat() method
        eat();       // âœ… calls the child (Dog)â€™s eat() method
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.showEating();
    }
}
```

### ğŸ–¥ï¸ Output:

```
Animal is eating.
Dog is eating.
```

Here:

* `super.eat()` â†’ explicitly calls the **parentâ€™s version** of `eat()`.
* `eat()` â†’ calls the **childâ€™s overridden** method.

---

## âš™ï¸ So why not `super.Animal`?

Because in Java:

* `super` refers to **the parent object of the current instance**, not the **class**.
* You canâ€™t write `super.Animal` â€” `Animal` is the *class name*, not a member of the superclass.

So this is âŒ invalid:

```java
super.Animal();   // âŒ wrong â€” you canâ€™t call a class like this
super.Animal;     // âŒ wrong â€” not a field or method
```

Instead, you should use:

```java
super();          // âœ… calls parent constructor
super.someMethod(); // âœ… calls parent method
```

---

### ğŸ§© Example with Constructor (`super(name)`)

```java
class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
        System.out.println("Animal constructor called for: " + name);
    }
}

class Dog extends Animal {
    public Dog(String name) {
        super(name); // âœ… correct way to call the parent constructor
        System.out.println("Dog constructor called for: " + name);
    }
}
```

Here, `super(name)` calls the **constructor of the `Animal` class**, not `super.Animal(name)`.

---

## âœ… In Short

| Syntax            | Meaning                                      | Valid? |
| ----------------- | -------------------------------------------- | ------ |
| `super()`         | Calls parent constructor                     | âœ…      |
| `super(args)`     | Calls parent constructor with parameters     | âœ…      |
| `super.method()`  | Calls a parent method                        | âœ…      |
| `super.field`     | Accesses a parent field (if not private)     | âœ…      |
| `super.ClassName` | âŒ Invalid â€” `super` is not a class reference | âŒ      |

---

### ğŸ§  Analogy

Think of `super` as saying:

> â€œUse my parentâ€™s version of this thing.â€

Not:

> â€œAccess my parent *class* directly.â€

---

Would you like me to show how `super` behaves **in multilevel inheritance** (e.g. `Animal â†’ Mammal â†’ Dog`)? It makes the concept even clearer.

